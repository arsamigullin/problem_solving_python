# the stack contains only increasing order of numbers# we pop the top item in stack when is greater or equal the current item in array# i.e. stack[-1]>=A[i]# Note: the area will be A[stack.pop()] * (i - stack[-1] - 1)# stack[-1] is left boundary of rectangle# stack.pop() - is the minimum height of rectangle# i - is right boundary of rectangle# Let's consider an example [2,1,5,6,2]. Stack initially s = [-1]# s.top() = -1, append 2 s = [-1, 0]# 2 >=1, pop 2(0), 1-(-1)-1 = 1, area = 2 * 1 = 2, s = [-1,1]# 1>=5, append 5, s = [-1,1,2]# 5>=6, append 6, s = [-1,1,2,3]# 6>=2, pop6(3), 4 - 2 - 1 = 1, area = 6 * 1 = 6 s=[-1,1,2]# 5>=2, pop5(2), 4 - 1 - 1 = 2, area = 5 * 2 = 10 s=[-1,1]# 1>=2, append 2, s = [-1,1,4]# Note, the stack is not empty and it keeps minimums that weren't considered yet. These minimums are# running all the way to the end of array, composing rectangles with height of minimums in stack and# width arr[stack.pop()] * (len(arr) - stack[-1] - 1)# this help to cover the cases like thatclass Solution:    def largestRectangleArea(self, A):        stack = [-1]        res = 0        for i in range(len(A)):            while stack[-1] != -1 and A[stack[-1]] >= A[i]:                j = stack.pop()                res = max(res, A[j] * (i - stack[-1] - 1))            stack.append(i)        while stack[-1] != -1:            j = stack.pop()            res = max(res, A[j] * (len(A) - stack[-1] - 1))        return resclass Solution1:    def largestRectangleArea(self, heights: list) -> int:        stack = []        min_left = [-1] * len(heights)        min_right = [-1] * len(heights)        min_mid = [-1] * len(heights)        for i in range(len(heights)):            while stack and heights[i]<heights[stack[-1]]:                stack.pop()            min_left[i] = -1 if not stack else heights[stack[-1]]            stack.append(i)        stack = []        for i in range(len(heights)):            while stack and heights[i]>heights[stack[-1]]:                stack.pop()            min_mid[i] = -1 if not stack else heights[stack[-1]]            stack.append(i)        for i in range(len(heights) - 1, -1, -1):             while stack and heights[i] < heights[stack[-1]]:                 stack.pop()             min_right[i] = len(heights) if not stack else heights[stack[-1]]             stack.append(i)        print('done')if __name__ == "__main__":    s = Solution()    #s.largestRectangleArea([2,1,2])    #s.largestRectangleArea([3,2,6,6,5,5,4,4,1,2])    s.largestRectangleArea([2,1,4,4,5,5,6,6,2,3])    s.largestRectangleArea([2,1,4,5,6,2,3])